version: '3.8'

x-base: &base
  image: ghcr.io/cauefaleiros/chatwoot:latest
  volumes:
    - storage_data:/app/storage
  environment:
    - RAILS_ENV=production
    - NODE_ENV=production
    - RAILS_LOG_TO_STDOUT=true
    - RAILS_SERVE_STATIC_FILES=true
    # LISTA COMPLETA DE VARIÁVEIS (Obrigatório para o Swarm injetar)
    - SECRET_KEY_BASE=${SECRET_KEY_BASE}
    - FRONTEND_URL=${FRONTEND_URL}
    - FORCE_SSL=${FORCE_SSL}
    - POSTGRES_HOST=${POSTGRES_HOST}
    - POSTGRES_PORT=${POSTGRES_PORT}
    - POSTGRES_DATABASE=${POSTGRES_DATABASE}
    - POSTGRES_USERNAME=${POSTGRES_USERNAME}
    - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    - REDIS_URL=${REDIS_URL}
    - REDIS_PASSWORD=${REDIS_PASSWORD}
    - ACTIVE_STORAGE_SERVICE=${ACTIVE_STORAGE_SERVICE}
    - MAILER_SENDER_EMAIL=${MAILER_SENDER_EMAIL}
    - SMTP_ADDRESS=${SMTP_ADDRESS}
    - SMTP_PORT=${SMTP_PORT}
    - SMTP_USERNAME=${SMTP_USERNAME}
    - SMTP_PASSWORD=${SMTP_PASSWORD}
    - SMTP_AUTHENTICATION=${SMTP_AUTHENTICATION}
    - SMTP_ENABLE_STARTTLS_AUTO=${SMTP_ENABLE_STARTTLS_AUTO}

services:
  # --- SERVIÇO NOVO: MIGRATION ---
  # Responsável apenas por preparar o banco. Roda e morre.
  migration:
    <<: *base
    depends_on:
      - postgres
      - redis
    # Comando único para preparar o banco
    command: ['bundle', 'exec', 'rails', 'db:chatwoot_prepare']
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure  # Só reinicia se der erro. Se der sucesso (exit 0), ele para.
      # Não precisa de healthcheck complexo pois é um job curto

  # --- SERVIÇO PRINCIPAL: RAILS ---
  rails:
    <<: *base
    depends_on:
      - postgres
      - redis
      # Em Swarm, o depends_on não espera a tarefa terminar, 
      # mas garante que a rede esteja pronta.
    ports:
      - '3010:3000'
    entrypoint: docker/entrypoints/rails.sh
    # MUDANÇA: Comando limpo, apenas sobe o servidor
    command: ['sh', '-c', 'bundle exec rails s -p 3000 -b 0.0.0.0']

    healthcheck:
      test:
        [
          'CMD-SHELL',
          'wget --no-verbose --tries=1 --spider http://localhost:3000/hc || exit 1',
        ]
      interval: 30s
      timeout: 10s
      retries: 5
      # MUDANÇA: start_period reduzido, pois não roda migration aqui
      start_period: 60s 

    deploy:
      replicas: 1
      update_config:
        parallelism: 1
        delay: 30s
        order: start-first
        failure_action: rollback
        monitor: 60s
      rollback_config:
        order: stop-first
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
      labels:
        - 'com.docker.swarm.image.pull=always'

  sidekiq:
    <<: *base
    depends_on:
      - postgres
      - redis
    command: ['bundle', 'exec', 'sidekiq', '-C', 'config/sidekiq.yml']

    healthcheck:
      test: ['CMD-SHELL', 'pgrep -f sidekiq || exit 1']
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s

    deploy:
      replicas: 1
      update_config:
        order: start-first
        failure_action: rollback
        monitor: 60s
      restart_policy:
        condition: on-failure
      labels:
        - 'com.docker.swarm.image.pull=always'

  postgres:
    image: pgvector/pgvector:pg16
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=${POSTGRES_DATABASE}
      - POSTGRES_USER=${POSTGRES_USERNAME}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    deploy:
      restart_policy:
        condition: on-failure

  redis:
    image: redis:alpine
    command: ['sh', '-c', 'redis-server --requirepass "$REDIS_PASSWORD"']
    volumes:
      - redis_data:/data
    ports:
      - '6379:6379'
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    deploy:
      restart_policy:
        condition: on-failure

volumes:
  storage_data:
  postgres_data:
  redis_data:

networks:
  default:
    driver: overlay
